#include <ros/ros.h>
#include <sensor_msgs/Image.h>
#include <sensor_msgs/image_encodings.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <opencv2/opencv.hpp>
#include <opencv2//core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/objdetect/objdetect.hpp>

#include <strings.h>
#include <iostream>
#include <unistd.h>
#include <vector>
#include "sensor_msgs/LaserScan.h"
#include <visualization_msgs/Marker.h>

#define WIDTH   50
#define HEIGHT  25

#define AngleofView 58

class depth_estimater
{
public:
    depth_estimater();
    ~depth_estimater();
    void rgbImageCallback(const sensor_msgs::ImageConstPtr& msg);
    void depthImageCallback(const sensor_msgs::ImageConstPtr& msg);

private:
    ros::NodeHandle nh;
    ros::Subscriber sub_rgb, sub_depth;
};

depth_estimater::depth_estimater()
{
    //sub_rgb = nh.subscribe<sensor_msgs::Image>("/camera/rgb/image_color", 1, &depth_estimater::rgbImageCallback, this);
    //sub_depth = nh.subscribe<sensor_msgs::Image>("/camera/depth/image", 1, &depth_estimater::depthImageCallback, this);
    //sub_rgb = nh.subscribe<sensor_msgs::Image>("/camera/rgb/image_raw", 1, &depth_estimater::rgbImageCallback, this);
    sub_rgb = nh.subscribe<sensor_msgs::Image>("/camera/rgb/image_rect_color", 1, &depth_estimater::rgbImageCallback, this);
    sub_depth = nh.subscribe<sensor_msgs::Image>("/camera/depth_registered/image_raw", 1, &depth_estimater::depthImageCallback, this);
    //sub_depth = nh.subscribe<sensor_msgs::Image>("/camera/depth_registered/sw_registered/image_rect_raw", 1, &depth_estimater::depthImageCallback, this);

}

depth_estimater::~depth_estimater(){}

cv::Mat mat_resizer(cv::Mat in_mat, int row, int col)
{
    cv::Mat tmp;
    tmp = cv::Mat::ones(in_mat.rows * row / in_mat.rows, in_mat.cols * col / in_mat.cols, CV_32FC1);
    cv::resize(in_mat, tmp, tmp.size(), cv::INTER_CUBIC);

    return tmp;
}

//RGB
void depth_estimater::rgbImageCallback(const sensor_msgs::ImageConstPtr& msg)
{
    int i, j;
    int x1, x2, y1, y2;
    int width = WIDTH;
    int height = HEIGHT;
    cv_bridge::CvImagePtr rgb_ptr;

    try
    {
        rgb_ptr = cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);
    }
    catch (cv_bridge::Exception& ex)
    {
        ROS_ERROR("error");
        exit(-1);
    }
    cv::Mat rgb_im = rgb_ptr->image;
    //cv::imshow("RGB image", rgb_ptr->image);
    //cv::imshow("RGB image", rgb_im);

    // 画像リサイズ
    cv::Mat img_resized;
    cv::resize(rgb_im, img_resized, cv::Size(), 0.4, 0.4);
    //cv::namedWindow("img_resized", CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO);
    //cv::imshow( "img_resized", img_resized );

    cv::HOGDescriptor hog;
    hog.setSVMDetector(cv::HOGDescriptor::getDefaultPeopleDetector());

    std::vector<cv::Rect> found;
    hog.detectMultiScale(img_resized, found, 0.2, cv::Size(8,8), cv::Size(16,16), 1.01, 2);

    std::vector<cv::Rect>::const_iterator it = found.begin();
    
    double rect_center_x = 0.0;
    double theta = 0.0;

	int8_t human_num = found.size();
    std::vector<double>angle;
	std::vector<double>:: iterator itr;
	

	//xtion:58
    for(; it!=found.end(); ++it)
    {
        cv::Rect r = *it;
        // 描画に際して，検出矩形を若干小さくする
        r.x += cvRound(r.width*0.1);
        r.width = cvRound(r.width*0.8);
        r.y += cvRound(r.height*0.07);
        r.height = cvRound(r.height*0.8);
        rect_center_x = cvRound((r.x+(r.x+r.width))/2);
        cv::rectangle(img_resized, r.tl(), r.br(), cv::Scalar(0,255,0), 3);
        theta = rect_center_x/img_resized.cols*AngleofView;
        angle.push_back(theta);
   
        /*std::cout << "r.tl:" << r.tl() << ",r.br:" << r.br() << std::endl;
		std::cout << "r.x:" << r.x << ",r.y:" << r.y << std::endl;
		std::cout << "r.width:" << r.width << ",r.height:" << r.height << std::endl;
		std::cout << "rect_center_x:" << rect_center_x <<  std::endl;
		std::cout << "theta:" << theta <<  std::endl;*/
    }

    for(itr = angle.begin();itr != angle.end();itr++)
 	{
   		std::cout << "found:" << found.size() << std::endl;
   		std::cout << "angle:" << *itr << std::endl;
    }

    if (found.size()==0)
    {
    	std::cout << "found:" << found.size() << std::endl;
    }

    // 結果の描画
    cv::namedWindow("result", CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO);
    cv::imshow( "result", img_resized );

    cv::waitKey(10);

}

//Depth
void depth_estimater::depthImageCallback(const sensor_msgs::ImageConstPtr& msg)
{
    cv_bridge::CvImageConstPtr depth_ptr;

    try
    {
        depth_ptr = cv_bridge::toCvCopy(msg,sensor_msgs::image_encodings::TYPE_32FC1);
    }
    catch(cv_bridge::Exception& ex)
    {
        ROS_ERROR("error");
        exit(-1);
    }

    cv::Mat depth_im = depth_ptr -> image;

    cv::Mat  depth_im_norm = depth_im.clone();
    cv::normalize(depth_im_norm, depth_im_norm, 1, 0, cv::NORM_MINMAX);
}

void msgCallback(const sensor_msgs::LaserScan::ConstPtr& msg )
{
    //受信したメッセージを表示する。
    //ROS_INFO("recieve msg: %d", msg->ranges.size());
    //ROS_INFO("recieve msg: %lf", msg->angle_min);
    ROS_INFO("recieve msg: %lf", msg->ranges[0]);
    /*ls_msg.angle_min = msg->angle_min;
    ls_msg.angle_max = msg->angle_max;
    ls_msg.angle_increment = msg->angle_increment;
    ls_msg.time_increment = msg->time_increment;
    ls_msg.scan_time = msg->scan_time;
    ls_msg.range_min = msg->range_min;
    ls_msg.range_max = msg->range_max;*/



    //ls_msg.ranges = msg->ranges;
    //ls_msg.intensities = msg->intensities;
    //std::copy(msg->ranges.begin(), msg->ranges.end(), std::back_inserter(ls_msg.ranges));
    //std::copy(msg->intensities.begin(), msg->intensities.end(), std::back_inserter(ls_msg.intensities));

	
    sensor_msgs::LaserScan ls_msg;
    ros::Rate loop_rate(50);
    ls_msg.angle_min = msg->angle_min;
    ls_msg.angle_max = msg->angle_max;
    ls_msg.angle_increment = msg->angle_increment;
    ls_msg.time_increment = msg->time_increment;
    ls_msg.scan_time = msg->scan_time;
    ls_msg.range_min = msg->range_min;
    ls_msg.range_max = msg->range_max;

    std::copy(msg->ranges.begin(), msg->ranges.end(), std::back_inserter(ls_msg.ranges));
    std::copy(msg->intensities.begin(), msg->intensities.end(), std::back_inserter(ls_msg.intensities));
    ros::Publisher scan_pub = nh.advertise<sensor_msgs::LaserScan>("scan_part", 100);
    loop_rate.sleep();
    ROS_INFO("recieve msg: %lf", ls_msg.angle_min);
    scan_pub.publish(ls_msg);
    
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "human_tracking_test");

    depth_estimater depth_estimater;
    //ros::NodeHandle nh;
    //ros::Subscriber ros_tutorial_sub = nh.subscribe("scan",100, msgCallback);
    ros::spin();
    return 0;
}
