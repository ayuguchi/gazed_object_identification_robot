/**
 * Test for the KalmanFilter class with 1D projectile motion.
 *
 * @author: Hayk Martirosyan
 * @date: 2014.11.15
 */

#include <iostream>
#include <vector>
#include <Eigen/Dense>
#include "kalman.hpp"

#include <people_msgs/PositionMeasurement.h>

template <typename T> std::string tostr(const T& t)
{
    std::ostringstream os; os<<t; return os.str();
}

static std::string fixed_frame = "odom";

class PeopleTracker{
private:
    ros::Rate r;
    ros::Subscriber ros_people_sub;
    ros::Subscriber ros_human_angle_sub;
    ros::Publisher ros_markers_pub,ros_text_pub,person_pos_pub,ros_markers_pub2;
    ros::NodeHandle nh1;
    std::vector<float> human_angle_hog;
    std::vector<float> reliability_lrf,reliability_hog;
    std::string track_id;
    int hog_in,track_index;
public:
    PeopleTracker(ros::NodeHandle nh):
    nh1(nh),r(10),track_id(""),hog_in(0)
    {

        ros_people_sub = nh1.subscribe("people",1, &PeopleTracker::msgCallback_PeopleTracker, this);
        ros_human_angle_sub = nh1.subscribe("human_angle",1, &PeopleTracker::msgCallback_HumanAngleHog, this);
        ros_markers_pub = nh1.advertise<visualization_msgs::Marker>("tracking_marker", 20);
        ros_markers_pub2 = nh1.advertise<visualization_msgs::Marker>("target_marker", 20);
        ros_text_pub = nh1.advertise<visualization_msgs::Marker>("tracking_text", 20);
        person_pos_pub = nh1.advertise<geometry_msgs::PoseStamped>("human_pose", 20);
    }

    void msgCallback_PeopleTracker(const people_msgs::People::ConstPtr& msg )
    {
        std::vector<people_msgs::Person> people = msg->people;
        int i=0;
        reliability_hog.clear();
        reliability_lrf.clear();
        track_id=-1;
        for(std::vector<people_msgs::Person>::iterator itr = people.begin(); itr != people.end() ; ++itr)
        {
            if(track_id == (*itr).name)track_index = i;
            //std::cout<<(*itr).name<<std::endl;
            visualization_msgs::Marker m;
            m.header.stamp = ros::Time::now();
            m.header.frame_id = fixed_frame;
            m.ns = "Person";
            m.id = i;
            m.type = m.TEXT_VIEW_FACING;
            m.pose.position.x = (*itr).position.x;
            m.pose.position.y = (*itr).position.y;
            m.pose.position.z = (*itr).position.z;
            float theta = atan2(m.pose.position.y, m.pose.position.x)*180.0/PI;
            //std::cout<<"theta:"<<theta<<", hog_angle: "<<human_angle_hog[0]<<std::endl;
            if(!human_angle_hog.empty()){
                float diff=180;
                for(std::vector<float>::iterator itr_f = human_angle_hog.begin();itr_f != human_angle_hog.end();++itr_f)
                    diff =std::min(diff,std::abs(theta-*itr_f));
                reliability_hog.push_back(((180-diff)/180)/2+(*itr).reliability/2);
                m.text = tostr((*itr).reliability)+", "+tostr(diff);
                hog_in=1;
            }else{
                reliability_lrf.push_back((*itr).reliability);
                m.text = tostr((*itr).reliability);
                hog_in=0;
            }
            float velocity_abs_tmp = std::sqrt(std::pow((*itr).velocity.x, 2) + std::pow((*itr).velocity.y, 2));
            m.text = (*itr).name;
            m.scale.x = .1;
            m.scale.y = .1;
            m.scale.z = 0.2;
            m.color.a = 1;
            m.lifetime = ros::Duration(0.1);
            m.color.b = (*itr).reliability;

            ros_text_pub.publish(m);
            /*r.sleep();
            i++;
            m.id = i;*/
            //m.header.stamp = ros::Time::now();
            m.type = m.SPHERE;
            ros_markers_pub.publish(m);
            i++;
        }

        int max_index, publish_ok=0;
        float target_reliability;
        if(hog_in)
        {
            max_index=std::distance(reliability_hog.begin(),std::max_element(reliability_hog.begin(),reliability_hog.end()));
            target_reliability = *std::max_element(reliability_hog.begin(),reliability_hog.end());
        }
       else
       {
            max_index = std::distance(reliability_lrf.begin(),std::max_element(reliability_lrf.begin(),reliability_lrf.end()));
            target_reliability = *std::max_element(reliability_lrf.begin(),reliability_lrf.end());
       }

        if(track_id == "" && hog_in == 1){
            track_id  = people[max_index].name;
            track_index = max_index;
            publish_ok=1;
        }
        else if(track_index != -1){
            track_id ="";
            publish_ok=1;
        }

        //Test human_pose publisher
        geometry_msgs::PoseStamped target_pose;
        target_pose.pose.position.x = people[track_index].position.x;
        target_pose.pose.position.y = people[track_index].position.y;

        float distance = std::sqrt(std::pow(people[track_index].position.x, 2) + std::pow(people[track_index].position.y, 2));
        float velocity_abs = std::sqrt(std::pow(people[track_index].velocity.x, 2) + std::pow(people[track_index].velocity.y, 2));
        std::cout << "target.name: " << people[track_index].name << std::endl;
        std::cout << "target.position.x: " << people[track_index].position.x << std::endl;
        std::cout << "target.position.y: " << people[track_index].position.y << std::endl;
        std::cout << "target.velocity.x: " << people[track_index].velocity.x << std::endl;
        std::cout << "target.velocity.y: " << people[track_index].velocity.y << std::endl;
        //std::cout << "target.reliability: " << target_reliability << std::endl;
        std::cout << "distance: " << distance << std::endl;
        std::cout << "velocity_abs: " << velocity_abs << std::endl;
        std::cout << ""<< std::endl;

        visualization_msgs::Marker m2;
        m2.header.stamp = ros::Time::now();
        m2.header.frame_id = fixed_frame;
        m2.ns = "TargetPerson";
        m2.type = m2.SPHERE;
        m2.pose.position.x = target_pose.pose.position.x;
        m2.pose.position.y = target_pose.pose.position.y;
        m2.color.r = 1.0f;
        m2.color.g = 0.0f;
        m2.color.b = 0.0f;
        m2.color.a = 0.5;
        m2.scale.x =  0.2;
        m2.scale.y =  0.2;
        m2.scale.z =  0.2;
        //m2.lifetime = ros::Duration(0.1);
        //ros_markers_pub2.publish(m2);

        /*if((target_reliability>0.4)&&((velocity_abs<0.1)||(distance>4.0)))
        {
            person_pos_pub.publish(target_pose);
            m2.lifetime = ros::Duration(0.3);
            ros_markers_pub2.publish(m2);
        }*/
        if(publish_ok)
        {
            m2.lifetime = ros::Duration(0.3);
            ros_markers_pub2.publish(m2);
        }


    }

    void msgCallback_HumanAngleHog(const std_msgs::Float32MultiArray::ConstPtr& array)
    {
        // print all the remaining numbers
        if(!array->data.empty())
            human_angle_hog.clear();
        for(std::vector<float>::const_iterator itr = array->data.begin(); itr != array->data.end(); ++itr)
        {
            //ROS_INFO("recieve human_angle_hog: %lf", *itr);
            human_angle_hog.push_back(*itr);
        }
        return;
    }
};

// 購読者ノードのメイン関数
int main(int argc, char **argv)
{
    // ノード名の初期化
    ros::init(argc, argv, "person_velocity_tracking");
    // ROSシステムとの通信のためのノードのハンドルを宣言
    ros::NodeHandle nh;
    PeopleTracker pt(nh);
    ros::spin();
    return 0;
}
int main(int argc, char* argv[]) {

  int n = 3; // Number of states
  int m = 1; // Number of measurements

  double dt = 1.0/30; // Time step

  Eigen::MatrixXd A(n, n); // System dynamics matrix
  Eigen::MatrixXd C(m, n); // Output matrix
  Eigen::MatrixXd Q(n, n); // Process noise covariance
  Eigen::MatrixXd R(m, m); // Measurement noise covariance
  Eigen::MatrixXd P(n, n); // Estimate error covariance

  // Discrete LTI projectile motion, measuring position only
  A << 1, dt, 0, 0, 1, dt, 0, 0, 0;
  C << 1, 0, 0;

  // Reasonable covariance matrices
  Q << .05, .05, .0, .05, .05, .0, .0, .0, .0;
  R << 5;
  P << .1, .1, .1, .1, 10000, 10, .1, 10, 100;

  std::cout << "A: \n" << A << std::endl;
  std::cout << "C: \n" << C << std::endl;
  std::cout << "Q: \n" << Q << std::endl;
  std::cout << "R: \n" << R << std::endl;
  std::cout << "P: \n" << P << std::endl;

  // Construct the filter
  KalmanFilter estimate_X(0,A, C, Q, R, P);
  KalmanFilter estimate_Y(0,A, C, Q, R, P);

  // Best guess of initial states
  Eigen::VectorXd x0(n);
  x0 << measurements[0], 1.0, 0.0;
  estimate_X.init(0,x0);

  Eigen::VectorXd y0(n);
  y0 << measurements[0], 1.0, 0.0;
  estimate_Y.init(0,y0);

  // Feed measurements into filter, output estimated states
  double t = 0;
  Eigen::VectorXd y(m);
  std::cout << "t = " << t << ", " << "x_hat[0]: " << kf.state().transpose() << std::endl;
  for(int i = 0; i < measurements.size(); i++) {
    t += dt;
    y << measurements[i];
    kf.update(y);
    std::cout << "t = " << t << ", " << "y[" << i << "] = " << y.transpose()
        << ", x_hat[" << i << "] = " << kf.state().transpose() << std::endl;
  }

  return 0;
}
